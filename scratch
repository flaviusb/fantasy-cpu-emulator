Signals:

Clocks: trigger things on rise/fall edge, have a clock tree / clock domain, can't be directly driven by a listener but can eg depend on the state of some other signal
Busses: Sample / drive at a point, maybe have pull up / pull down set so driving it only affects it in the relevant way eg driving 0 when something else is driving 1 might not do anything
Interrupts: Kind of like a clock, has a trigger?
Network: Model propagation delay somehow?

Clocked vs combinatorial stuff?


---


A = top
B = side

or

 |0  1
-+-----
0|0  1
 |
1|1  1

nor

 |0  1
-+-----
0|1  0
 |
1|0  0

orn

 |0  1
-+-----
0|1  1
 |
1|1  0

Current status: So ⌜orn⌝ is ⌜⊃⌝.

and

 |0  1
-+-----
0|0  0
 |
1|0  1

andn

 |0  1
-+-----
0|0  1
 |
1|0  0

All 16 binary logical ops: l r dest

Add, sub
integer signed, integer unsigned
36 bit, 32 bit zeroing high, 32 bit preserve high, 32 bit flags (sat/carry) high, 2 × packed 16 bit flags high, 4 × 8 packed bit flags high
saturating

and also
add, sub
fp signed
36 bit, 32 bit flags high, 32 bit zeroing high, 32 bit preserve high 
saturating

mul, div
integer signed, integer unsigned, fp signed
36 bit, 32 bit zeroing high, 32 bit flags high
saturating

jumps

set jump priority queue on unstall dest1 dest2 dest3
try jumps if unstalled: dest1 dest2 dest3
jump if equal: l r dest
jump if not equal: l r dest
jump if eq imm: imm src dest

bitops

popcnt
roll
ror

4 way instruction
select l r choice_also_dest
fma a b c_and_dest

---

banana todo

4 major instruction format kinds

Format 0:      000000 0000000000 0000000000 [opcode_0place; 10]
Format 1:      000000 0000000000 [opcode_1place; 10] [address1; 10]
Format 2-full: 000000 0 [opcode_2place_full; 9] [address1; 10] [address2; 10]
Format 2-imm:  000000 1 [opcode_2place_imm; 4] [imm; 5] [address1; 10] [address2; 10]
Format 3:      [opcode_3place; 6] [address1; 10] [address2; 10] [address3; 10]

where opcode_{1,2,3}place is nonzero.

Up to 1024 format 0 instructions
Up to 1023 format 1 and 2 instructions
31 format 3 instructions

Format 3:

8 × logic: Nor, Material Nonimplication, XOR, NAND, AND, XNOR, Material Conditional, OR
x × arithmetic: ???
y × jumps
z × bitmanip

Format 2-full:
3 × logic with mask: bitset (eg T with mask), bitunset (eg F with mask), bitflip (eg ¬ with mask)
3 × logic: ¬, = (eg copy), ←→ (eg swap)

Format 2-imm:
rotate left/right, shift left right with fill 0/1, 
shuffle
unshuffle

Format 1:
2 × logic: T, F 

---

yam chip

banks in addition to channel IO

4 major instruction format kinds

Format 0:      00000000 00000000 00000000 [opcode_0place; 8]
Format 1:      00000000 00000000 [opcode_1place; 8] [address1; 8]
Format 2-full: 00000000 000 [opcode_2place_full; 5] [address1; 8] [address2; 8]
Format 2-imm:  0000000 [opcode_2place_imm; 4] [imm; 5] [address1; 8] [address2; 8]
Format 3:      [opcode_3place; 8] [address1; 8] [address2; 8] [address3; 8]

Format 2-imm:

roli, rori, shl0i, shl1i, shr0i, shr1i, grevi, shuffle, unshuffle

Format 2-full:
3 × logic with mask: bitset (eg T with mask), bitunset (eg F with mask), bitflip (eg ¬ with mask)
3 × logic: ¬, = (eg copy), ←→ (eg swap)

bank switching: 
